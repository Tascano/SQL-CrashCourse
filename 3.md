üß© Section 3 ‚Äî Querying Fundamentals üîç
This section covers the essential DQL commands used for all data retrieval, analysis, and reporting.

3.1 SELECT, WHERE, ORDER BY
The foundation of every query.

| Command | Objective |
|---------|-----------|
| SELECT | Specify columns (* for all), expressions, or aggregated data. |
| WHERE | Filter rows based on specific conditions (e.g., equality, comparison, logical operators AND/OR/NOT). |
| ORDER BY | Sort the result set by one or more columns in ascending (ASC) or descending (DESC) order. |

üìù Exercise 3.1 (Finding US Users)
Find the name and signup_date of all users from the USA, ordered by their signup date, newest first.

```
SELECT name, signup_date
FROM users
WHERE country = 'USA'
ORDER BY signup_date DESC;
```

3.2 Aggregations (COUNT, SUM, AVG, MIN, MAX)
These functions perform calculations across a set of rows and return a single summary value.

| Function | Purpose | Example Use Case |
|----------|---------|-----------------|
| COUNT() | Counts the number of rows (or non-NULL values). | Total number of users. |
| SUM() | Calculates the sum of a set of values. | Total engagement time across all users. |
| AVG() | Calculates the average of a set of values. | Average duration of a video view. |
| MIN() | Finds the minimum value. | Earliest signup date. |
| MAX() | Finds the maximum value. | Longest duration of an article read. |


üìù Exercise 3.2 (Basic Stats)
3.2.1. Find the total number of entries in the content table.

3.2.2. Find the maximum duration recorded for any single engagement event.

```
-- Solution 3.2.1
SELECT COUNT(*) AS total_content_count
FROM content;

-- Solution 3.2.2
SELECT MAX(duration_in_seconds) AS max_duration
FROM engagement;
```

3.3 GROUP BY and HAVING
These are used together with aggregate functions to perform calculations on subsets of data.

| Command | Objective |
|---------|-----------|
| GROUP BY | Groups rows with the same values into a summary row, allowing aggregate functions to run per group. |
| HAVING | Filters groups based on an aggregate condition. Crucially, it is the filter for GROUP BY, just as WHERE is the filter for SELECT. |


üìù Exercise 3.3 (Grouping and Filtering)
3.3.1. Calculate the total number of users per country.

3.3.2. Filter the results from (1) to show only countries with more than one user.

```
-- Solution 3.3.1 & 3.3.2 Combined
SELECT 
    country, 
    COUNT(user_id) AS user_count
FROM users
GROUP BY country
HAVING COUNT(user_id) > 1
ORDER BY user_count DESC;
```

3.4 JOINs (INNER, LEFT, RIGHT, FULL, CROSS)
JOINs are fundamental to relational databases; they combine rows from two or more tables based on a related column between them (usually the Foreign Key).

| JOIN Type | Result | Analogy |
|-----------|--------|---------|
| INNER JOIN | Returns only rows where there is a match in both tables. | Finding people who have both a user record AND an active subscription. |
| LEFT JOIN | Returns all rows from the left table, and the matching rows from the right table. Non-matches in the right table show NULL. | All users, and their subscription data if it exists (if not, subscription columns are NULL). |
| RIGHT JOIN | Returns all rows from the right table, and the matching rows from the left table. (Rarely used, usually converted to a LEFT JOIN). | All content, and the engagement data if it exists (if not, engagement columns are NULL). |
| FULL (OUTER) JOIN | Returns all rows when there is a match in either the left or the right table. Non-matches get NULL. | All users AND all content, showing where they match in the engagement table. |
| CROSS JOIN | Returns the Cartesian product of the two tables (every row in the left table combined with every row in the right table). | Useful for generating sample data or combinations, but often huge and rarely used in production reporting. |


üìù Exercise 3.4 (INNER JOIN)
Find the name of the user and the title of the content for all recorded engagement events.

```
SELECT
    u.name AS user_name,
    c.title AS content_title,
    e.event_type
FROM engagement e
INNER JOIN users u ON e.user_id = u.user_id
INNER JOIN content c ON e.content_id = c.content_id;

```

3.5 Subqueries (Simple and Correlated)
A Subquery (or inner query) is a query nested inside another SQL query (the outer query).

| Type | Objective |
|------|-----------|
| Simple Subquery | Runs once and passes its result to the outer query. Often used in the WHERE clause with operators like IN, ANY, ALL. |
| Correlated Subquery | Runs once for every row processed by the outer query. It relies on the outer query's data, making it less performant but useful for complex row-by-row comparisons. |

üìù Exercise 3.5 (Simple Subquery)
Find the names of users who have a record in the engagement table.

```
SELECT name
FROM users
WHERE user_id IN (
    SELECT DISTINCT user_id 
    FROM engagement
);
```

3.6 Common Table Expressions (CTEs)
A Common Table Expression (CTE), defined using the WITH clause, is a temporary, named result set that you can reference within a single SELECT, INSERT, UPDATE, or DELETE statement. They improve query readability and complexity management.

| Benefit | Explanation |
|---------|-------------|
| Readability | Breaks complex, multi-step logic into clear, named, sequential steps. |
| Reusability | A CTE can be referenced multiple times within the same final query. |
| Self-Referencing | The foundation for Recursive CTEs (Section 5). |


üìù Exercise 3.6 (CTE for Clarity)
Use a CTE to first calculate the total engagement duration for each user, and then select the user name and their total duration.

```
WITH UserTotalDuration AS (
    -- Step 1: Calculate the total engagement time per user
    SELECT
        user_id,
        SUM(duration_in_seconds) AS total_duration
    FROM engagement
    GROUP BY user_id
)
-- Step 2: Join the results with the users table to get the name
SELECT
    u.name,
    t.total_duration
FROM users u
INNER JOIN UserTotalDuration t ON u.user_id = t.user_id
ORDER BY t.total_duration DESC;
```

3.7 CASE WHEN for Conditional Logic
The CASE statement allows you to perform if/then/else logic directly within your query, which is crucial for creating categories, labels, and conditional calculations.

| Clause | Purpose |
|--------|---------|
| CASE | Starts the conditional logic block. |
| WHEN [condition] | The "IF" condition. |
| THEN [result] | The value to return if the condition is true. |
| ELSE [result] | The optional value to return if no WHEN condition is met. |
| END | Closes the conditional block. The CASE statement must have an END. |


Exercise 3.7 (Conditional Labeling)
3.7.1 List all content titles and create a new column, Content_Length_Bucket, where:
3.7.2 Book and Video content is labeled 'Long-Form'.
3.7.3 Article content is labeled 'Short-Form'.
3.7.4 Everything else is labeled 'Other'.

```
SELECT
    title,
    type,
    CASE
        WHEN type IN ('Book', 'Video') THEN 'Long-Form'
        WHEN type = 'Article' THEN 'Short-Form'
        ELSE 'Other' -- Catches any unknown types
    END AS Content_Length_Bucket
FROM content;
```